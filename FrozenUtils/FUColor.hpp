/*
 * @Author: Frozen (https://github.com/AlterFrozen)
 * @Date: 2022-09-12 18:50:31
 * @LastEditTime: 2022-09-13 21:43:17
 * @LastEditors: Please set LastEditors
 * @Description: A collection of color functions (C++20)

███████╗██████╗  ██████╗ ███████╗███████╗███╗   ██╗    ██╗   ██╗████████╗██╗██╗     ███████╗
██╔════╝██╔══██╗██╔═══██╗╚══███╔╝██╔════╝████╗  ██║    ██║   ██║╚══██╔══╝██║██║     ██╔════╝
█████╗  ██████╔╝██║   ██║  ███╔╝ █████╗  ██╔██╗ ██║    ██║   ██║   ██║   ██║██║     ███████╗
██╔══╝  ██╔══██╗██║   ██║ ███╔╝  ██╔══╝  ██║╚██╗██║    ██║   ██║   ██║   ██║██║     ╚════██║
██║     ██║  ██║╚██████╔╝███████╗███████╗██║ ╚████║    ╚██████╔╝   ██║   ██║███████╗███████║
╚═╝     ╚═╝  ╚═╝ ╚═════╝ ╚══════╝╚══════╝╚═╝  ╚═══╝     ╚═════╝    ╚═╝   ╚═╝╚══════╝╚══════╝                                                                                          

[Logo Generated By]>> http://patorjk.com/software/taag/ 
*/

#ifndef _FUCOLOR_HPP_
#define _FUCOLOR_HPP_

#include <algorithm>
#include <array>
#include <cmath>

namespace FU
{
    static class ColorConverter
    {
    private:
        using Byte = unsigned char;

    public:
        /**
         * Convert RGBColor(float[3]) to Ward's compacted RGB format(uint32_t)
         * @param {float[3]} src_color
         * @param {uint32_t&} res_color
         * @return {void}
         */        
        static void rgb_to_rgbWard(const float src_color[], uint32_t& res_color)
        {
            res_color = 0;
            static auto Frexp = [](float num)->std::pair<float, int>
            {
                float mantissa = num;
                int exponent = 0;
                while (mantissa > 1.0)
                {
                    mantissa /= 2.0;
                    exponent++;
                }
                while (mantissa < 0.5)
                {
                    mantissa *= 2.0;
                    exponent--;
                }
                return { mantissa, exponent };
            };

            float primary = std::max(src_color[0], std::max(src_color[1], src_color[2]));
            if (primary > std::numeric_limits<float>::epsilon())
            {
                auto v = Frexp(primary);
                int scale = (v.first / primary) * 255;
                res_color = (res_color + static_cast<int>(scale * src_color[0])) << 8;
                res_color = (res_color + static_cast<int>(scale * src_color[1])) << 8;
                res_color = (res_color + static_cast<int>(scale * src_color[2])) << 8;
                res_color += v.second + 128; // map to unsigned char otherwise the sign bit will impact result
            }
        }

        /**
         * Convert Ward's compacted RGB format(uint32_t) to RGBColor(float[3])
         * @param {uint32_t} src_color
         * @param {float[3]} res_color
         * @return {void}
         */        
        static void rgbWard_to_rgb(uint32_t src_color, float  res_color[])
        {
            res_color[0] = res_color[1] = res_color[2] = .0f;
            static auto Ldexp = [](Byte exponet)->float
            {
                return std::pow(2.0, static_cast<char>(exponet - 128));
            };

            Byte exponent = static_cast<Byte>(src_color);
            if (exponent != 0)
            {
                float v = Ldexp(exponent);
                float scale = (1.0 / 255.0) * v;
                for (int i = 1; i <= 3; ++i) res_color[3 - i] = scale * static_cast<Byte>(src_color >> (i * 8));
            }
        }
    };
}// namespace FU

#endif