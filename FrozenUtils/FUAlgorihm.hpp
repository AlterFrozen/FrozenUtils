/*
 * @Author: Frozen (https://github.com/AlterFrozen)
 * @Date: 2022-09-13 17:07:31
 * @LastEditTime: 2022-09-13 21:48:50
 * @LastEditors: Please set LastEditors
 * @Description: A collection of algorithms (C++20)

███████╗██████╗  ██████╗ ███████╗███████╗███╗   ██╗    ██╗   ██╗████████╗██╗██╗     ███████╗
██╔════╝██╔══██╗██╔═══██╗╚══███╔╝██╔════╝████╗  ██║    ██║   ██║╚══██╔══╝██║██║     ██╔════╝
█████╗  ██████╔╝██║   ██║  ███╔╝ █████╗  ██╔██╗ ██║    ██║   ██║   ██║   ██║██║     ███████╗
██╔══╝  ██╔══██╗██║   ██║ ███╔╝  ██╔══╝  ██║╚██╗██║    ██║   ██║   ██║   ██║██║     ╚════██║
██║     ██║  ██║╚██████╔╝███████╗███████╗██║ ╚████║    ╚██████╔╝   ██║   ██║███████╗███████║
╚═╝     ╚═╝  ╚═╝ ╚═════╝ ╚══════╝╚══════╝╚═╝  ╚═══╝     ╚═════╝    ╚═╝   ╚═╝╚══════╝╚══════╝                                                                                     

[Logo Generated By]>> http://patorjk.com/software/taag/ 
*/

#ifndef _FUALGORITHM_HPP_
#define _FUALGORITHM_HPP_

#include <vector>
#include <queue>
#include <cassert>

namespace FU
{

    /**
     * [KNN Algorithm]
     * Please read the intro of each parameter and the example at the end of the anotation before using
     * @param {const Container&} _ContainerThe: container of the dataset
     * @param {size_t} idx_home: The indice of the home number
     * @param {uint32_t} k: How many neighbors do you want to search
     * @param {size_t} idx_start: The start indice of searching range in the container
     * @param {size_t} idx_end: The end indice of searching range in the container
     * @param {const _Estimator} _DistanceEstimator: The function for computing distance
     * @param {const _Estimator} _Greater: The function for comparing distance(Greater)
     * @return {std::vector<size_t>} K indices of K neighbors in the _Container
     * @param ---
     * @param Example>>
     * @param | std::vector<double> v{1,10,11,14,21};
     * @param | auto knn_idx = kNearestNeighbors(v, 1, 3, 0, v.size(),// Return the indices of the nearest 3 neighbors of v[1](i.e. 10) from 0 to v.size()
     * @param |            [](decltype(v.front()) a, decltype(v.front()) b)->double{ return std::abs(a-b);}, // function for computing distance
     * @param |            [](double distA, double distB)->bool{return distA > distB;}); // function for comparing distance(Greater)
     * @param | for (auto idx : knn_idx) std::cout << v[idx] << ' '; //OUTPUT: 11 14 1
     */    
    template<class Container, class _Estimator, class _DistanceCmp>
    std::vector<size_t> kNearestNeighbors(
                        const Container& _Container,
                        size_t idx_home, uint32_t k, 
                        size_t idx_start, size_t idx_end,
                        const _Estimator _DistanceEstimator,
                        const _DistanceCmp _Greater)
    {
        assert((idx_start <= idx_home && idx_home <= idx_end) && "Index Range Error");
        assert((idx_end - idx_start) > k && "No existing at least K neighbors!");

        auto& container = const_cast<Container&>(_Container);

        using _DataType = decltype(container[idx_home]);
        using _DistType = decltype(_DistanceEstimator(container[idx_home], container[idx_home]));
        using _IndexAndDist = std::pair<size_t, _DistType>;

        auto cmp = [_Greater](const _IndexAndDist& a, const _IndexAndDist& b)->bool
        {
            return _Greater(a.second, b.second);
        };

        std::priority_queue<_IndexAndDist, std::vector<_IndexAndDist>, decltype(cmp)> minHeap(cmp);

        for (size_t idx = idx_start; idx < idx_end; ++idx)
        {
            if (idx == idx_home) continue;
            minHeap.emplace(_IndexAndDist{idx, _DistanceEstimator(container[idx_home], container[idx])});
        }
        
        std::vector<size_t> knn_idx(k);
        for(uint32_t i = 0; i < k; ++i) 
        {
            knn_idx[i] = minHeap.top().first;
            minHeap.pop();
        }
        return knn_idx;
    }

}// namespace FU

#endif