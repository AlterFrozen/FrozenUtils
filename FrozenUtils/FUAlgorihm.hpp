/*
 * @Author: Frozen (https://github.com/AlterFrozen)
 * @Date: 2022-09-13 17:07:31
 * @LastEditTime: 2022-09-14 17:59:38
 * @LastEditors: Please set LastEditors
 * @Description: A collection of algorithms (C++20)

███████╗██████╗  ██████╗ ███████╗███████╗███╗   ██╗    ██╗   ██╗████████╗██╗██╗     ███████╗
██╔════╝██╔══██╗██╔═══██╗╚══███╔╝██╔════╝████╗  ██║    ██║   ██║╚══██╔══╝██║██║     ██╔════╝
█████╗  ██████╔╝██║   ██║  ███╔╝ █████╗  ██╔██╗ ██║    ██║   ██║   ██║   ██║██║     ███████╗
██╔══╝  ██╔══██╗██║   ██║ ███╔╝  ██╔══╝  ██║╚██╗██║    ██║   ██║   ██║   ██║██║     ╚════██║
██║     ██║  ██║╚██████╔╝███████╗███████╗██║ ╚████║    ╚██████╔╝   ██║   ██║███████╗███████║
╚═╝     ╚═╝  ╚═╝ ╚═════╝ ╚══════╝╚══════╝╚═╝  ╚═══╝     ╚═════╝    ╚═╝   ╚═╝╚══════╝╚══════╝                                                                                     

[Logo Generated By]>> http://patorjk.com/software/taag/ 
*/

#ifndef _FUALGORITHM_HPP_
#define _FUALGORITHM_HPP_

#include <vector>
#include <queue>
#include <algorithm>
#include <cassert>
#include <chrono>
#include <random>

namespace
{
    using Clock = std::chrono::high_resolution_clock;
    const Clock::time_point TIME_SEED = Clock::now();

    template<class Container>
    size_t _partition(Container& data, size_t start, size_t end)
    {
        assert(start < end && "Indice Error: start >= end");

        size_t verge = end - 1;
        static std::default_random_engine e((Clock::now() - ::TIME_SEED).count());
        static std::uniform_int_distribution<size_t> uniDis(start, verge);
        size_t divPos = uniDis(e);

        std::swap(data[divPos], data[verge]);
        size_t pivot = start;
        for (divPos = start; divPos < end; ++divPos)
            if (data[divPos] < data[verge] && pivot++ != divPos) std::swap(data[divPos], data[pivot]);

        std::swap(data[pivot], data[verge]);
        return pivot;
    }
}

namespace FU
{

    /**
     * [KNN Algorithm]
     * Please read the intro of each parameter and the example at the end of the anotation before using
     * @param {const Container&} _ContainerThe: container of the dataset
     * @param {size_t} idx_home: The indice of the home number
     * @param {uint32_t} k: How many neighbors do you want to search
     * @param {size_t} idx_start: The start indice of searching range in the container
     * @param {size_t} idx_end: The end indice of searching range in the container
     * @param {const _Estimator} _DistanceEstimator: The function for computing distance
     * @param {const _Estimator} _Greater: The function for comparing distance(Greater)
     * @return {std::vector<size_t>} K indices of K neighbors in the _Container
     * @param ---
     * @param Example>>
     * @param | std::vector<double> v{1,10,11,14,21};
     * @param | auto knn_idx = kNearestNeighbors(v, 1, 3, 0, v.size(),// Return the indices of the nearest 3 neighbors of v[1](i.e. 10) from 0 to v.size()
     * @param |            [](decltype(v.front()) a, decltype(v.front()) b)->double{ return std::abs(a-b);}, // function for computing distance
     * @param |            [](double distA, double distB)->bool{return distA > distB;}); // function for comparing distance(Greater)
     * @param | for (auto idx : knn_idx) std::cout << v[idx] << ' '; //OUTPUT: 11 14 1
     */    
    template<class Container, class _Estimator, class _DistanceCmp>
    std::vector<size_t> kNearestNeighbors(
                        const Container& _Container,
                        size_t idx_home, uint32_t k, 
                        size_t idx_start, size_t idx_end,
                        const _Estimator _DistanceEstimator,
                        const _DistanceCmp _Greater)
    {
        if (k == 0) return {};
        assert((idx_start <= idx_home && idx_home <= idx_end) && "Index Range Error");
        assert((idx_end - idx_start) > k && "No existing at least K neighbors!");

        auto& container = const_cast<Container&>(_Container);

        using _DataType = decltype(container[idx_home]);
        using _DistType = decltype(_DistanceEstimator(container[idx_home], container[idx_home]));
        using _IndexAndDist = std::pair<size_t, _DistType>;

        auto cmp = [_Greater](const _IndexAndDist& a, const _IndexAndDist& b)->bool
        {
            return !_Greater(a.second, b.second);
        };

        std::priority_queue<_IndexAndDist, std::vector<_IndexAndDist>, decltype(cmp)> maxHeap(cmp);

        for (size_t idx = idx_start; idx < idx_end; ++idx)
        {
            if (idx == idx_home) continue;

            _DistType dist = _DistanceEstimator(container[idx_home], container[idx]);
            if (idx - idx_start >= k) 
            {
                if (maxHeap.top().second > dist)
                {
                    maxHeap.pop();
                    maxHeap.emplace(_IndexAndDist{idx, dist});
                }
            } else maxHeap.emplace(_IndexAndDist{idx, dist});
        }
        
        std::vector<size_t> knn_idx;
        knn_idx.reserve(k);
        while(!maxHeap.empty())
        {
            knn_idx.emplace_back(maxHeap.top().first);
            maxHeap.pop();
        }
        return knn_idx;
    }

}// namespace FU

#endif